################################################################################
# Helper scripts for polygenic risk score.
# Apr. 2, 2021
# Daniel Gatti
# dmgatti@coa.edu
################################################################################

# getMAF(): Get minor allele frequency fora set of SNPs..
# writePLINK(): Write genotype and phenotype data to PLINK format.

require(qtl2)

# For a given set of SNPs, calculate the minor allele frequency for each SNP.
# Arguments:
# probs: qtl2-style genoprobs. List of 3D numeric arrays.
# map:   qtl2-style physical map. List of numeric vectors.
# chr:   Character. A single chromosome name in probs and map.
# snp_func: SNP query function as generated by qtl2::create_variant_query_func().
# Returns: named numeric vector containing MAF.
getMAF = function(probs, map, chr, snp_func) {

  # Query DB file and get SNPs.
  snps = snp_func(chr = chr, start = 0, end = 200)
  # Create snpinfo object.
  snpinfo  = index_snps(map, snps)
  # Get SNP probs and keep one allele.
  snpprobs = genoprob_to_snpprob(probs, snpinfo)[[1]][,1,]
  
  # Multiply by 2 and round to get discreet alleles. 
  snpprobs = round(2 * snpprobs)
  
  # Get allele counts.
  allele_freq = apply(snpprobs, 2, table)
  
  # Free up memory.
  rm(snps, snpinfo, snpprobs)
  gc()
  
  # Get sample counts at each SNP. This allows for missing data at different SNPs.
  num_samples = sapply(allele_freq, sum)
  # Convert to allele frequency.
  allele_freq = mapply(FUN ='/', allele_freq, num_samples)
  # Check the number of alleles. If we have more than three, fail.
  num_alleles = sapply(allele_freq, length)
  if(max(num_alleles) > 3) {
    stop(paste('ERROR" unexpected allele length:', max(num_alleles), '. We expect no more than three alleles.'))
  } # if(max(num_alleles) > 3)
  
  # Return vector for MAF.
  maf = setNames(rep(0, length(allele_freq)), names(allele_freq))
  
  for(j in seq_along(allele_freq)) {
    
    if(num_alleles[j] == 1) {
      maf[j] = 0.0
    } else if(num_alleles[j] == 2) {
      
      # We only add the het and assume the homozygote is the major allele.
      # This seems like more of an indeterminate case since we don't observe one allele.
      if('1' %in% names(allele_freq[[j]])) {
        maf[j] = allele_freq[[j]]['1'] / 2
      } else {
        # Otherwise, we have two homozygotes. Choose the lower frequency.
        maf[j] = min(allele_freq[[j]], na.rm = TRUE)
      } # else

    } else if(num_alleles[j] == 3) {

      maf0 = allele_freq[[j]]['0'] + allele_freq[[j]]['1'] / 2
      # Flip MAF if we calculated the major allele.
      if(maf0 > 0.5) {
        maf0 = 1.0 - maf0
      } # if(maf0 > 0.5)
      maf[j] = maf0

    } # else if(num_alleles[j] == 3)

  } # for(j)

  return(maf)

} # getMAF()


# Write genotype and phenotype data to PLINK text format.
# This function only write out the unique SDP SNPs, not all SNPs.
# Using PLINK v1.90b6.21 64-bit (19 Oct 2020) format.
# Using transposed text format with .tfam and .tped files.
# Arguments:
# probs: qtl2-style genoprobs. List of 3D numeric arrays.
# map:   qtl2-style physical map. List of numeric vectors.
# pheno: data.frame containing phenotypes.
# snp_func: SNP query function as generated by qtl2::create_variant_query_func().
# path: path to output directory, with file prefix. e.g. /data/projects/mice/plink
#       The function will append '.map' and '.ped' to this path prefix.
# Actions: 
# Returns: Nothing.
writePLINK = function(probs, map, pheno, snp_func, path) {
  
  # Synch up samples.
  if(all(rownames(pheno) == rownames(probs[[1]]))) {
    samples = sort(intersect(rownames(pheno), rownames(probs[[1]])))
    pheno = pheno[samples,]
    for(i in seq_along(probs)) {
      probs[[i]] = probs[[i]][samples,,]
    } # for(i)
  } # if(all(rownames(pheno) == rownames(probs[[1]])))
  
  tfam_file = paste0(path, '.tfam')
  tped_file = paste0(path, '.tped')

  # tfam file.
  # Contains no header line, and one line per sample with 2V+6 fields where V is the number of variants. 
  # The first six fields are the same as those in a .fam file. 
  # 1. Family ID ('FID')
  # 2. Within-family ID ('IID'; cannot be '0')
  # 3. Within-family ID of father ('0' if father isn't in dataset)
  # 4. Within-family ID of mother ('0' if mother isn't in dataset)
  # 5. Sex code ('1' = male, '2' = female, '0' = unknown)
  # 6. Phenotype value ('1' = control, '2' = case, '-9'/'0'/non-numeric = missing data if case/control)
  
  # Create fake family and parent IDs.
  # In qtl2, 0 = F and 1 = M. In PLINK, 1 = M and 2 = F.
  sex = pheno$sex
  sex[sex == 0] = 2
  tfam_output = data.frame(fid    = 0,
                           iid    = dimnames(probs[[1]])[1],
                           father = 0,
                           mother = 0,
                           sex    = sex,
                           pheno  = pheno$HCC + 1) # Must be 1 = control, 2 = case.
  
  write.table(tfam_output, file = tfam_file, append = F, quote = F, sep = ' ', 
              row.names = FALSE, col.names = FALSE)
    
  for(chr in names(map)) {
    
    print(paste('CHR:', chr))
    
    # Query DB file and get SNPs.
    snps = snp_func(chr = chr, start = 0, end = 200)
    # Create snpinfo object.
    snpinfo  = index_snps(map, snps)
    # Get SNP probs.
    snpprobs = genoprob_to_snpprob(probs, snpinfo)[[1]]
    
    rm(snps)
    gc()
    
    # As best I can tell, allele '1' in the SNP file corresponds to allele 'A'
    # in the snpprobs.
    
    # tped file.
    # A text file with no header file, and one line per variant with the following 3-4 fields:
    # 1. Chromosome code. PLINK 1.9 also permits contig names here, but most older programs do not.
    # 2. Variant identifier
    # 3. Position in morgans or centimorgans (optional; also safe to use dummy value of '0')
    # 4. Base-pair coordinate
    #
    # Contains no header line, and one line per variant with 2N+4 fields where N is the number 
    # of samples. The first four fields are the same as those in a .map file. The fifth and 
    # sixth fields are allele calls for the first sample in the .tfam file ('0' = no call); 
    # the 7th and 8th are allele calls for the second individual; and so on.
    
    # Create the map part of file.
    snpinfo   = subset(snpinfo, !duplicated(snpinfo$index))
    map_output = with(snpinfo, data.frame(chr, snp_id, 0, pos * 1e6))
    
    snpprobs = round(2 * snpprobs)
    num_samples = dim(snpprobs)[1]
    num_snps    = dim(snpprobs)[3]
    
    geno = matrix('', nrow = num_snps, ncol = 2 * num_samples)
    
    for(s in 1:num_snps) {
      
      # Get snpsprobs for current SNP.
      pr = snpprobs[,1,s]
      # Get SNP ID
      snp_id = dimnames(snpprobs)[[3]][s]
      # Find row in snpinfo with current SNP. All of these SNPs should be index SNPs.
      si_row = which(snpinfo$snp_id == snp_id)
      # Get the alleles and split them.
      alleles = strsplit(snpinfo$alleles[si_row], split = '\\|')[[1]]
      # Assign two letter genotypes with 0 = first allele.
      gt = matrix(alleles[1], nrow = length(pr), ncol = 2)
      het = which(pr == 1)
      gt[het, 1] = alleles[2]
      homo2 = which(pr == 2)
      gt[homo2,] = rep(alleles[2], 2)
      geno[s,] = as.vector(t(gt))

    } # for(s)

    tped_output = cbind(map_output, geno)
    
    write.table(tped_output, file = tped_file, append = chr != names(probs)[1], sep = ' ', 
                row.names = FALSE, col.names = FALSE, quote = FALSE)
    
  } # for(chr)

} # writePLINK()


# Test data set.
load('/media/dmgatti/hdb/projects/ColoState/data/HZEproject_qtl2.Rdata')
snp_func = create_variant_query_func(dbfile = '/media/dmgatti/hda/data/MUGA/hsnpt_variants.sqlite')

# Synch up samples.
if(all(rownames(pheno) == rownames(probs[[1]]))) {
  samples = sort(intersect(rownames(pheno), rownames(probs[[1]])))
  pheno = pheno[samples,]
  for(i in seq_along(probs)) {
    probs[[i]] = probs[[i]][samples,,]
  } # for(i)
} # if(all(rownames(pheno) == rownames(probs[[1]])))

maf = vector('list', length(probs))
names(maf) = names(probs)

for(i in seq_along(probs)) {
  
  # Get current chromosome.
  chr = names(probs)[i]
  print(chr)
  
  maf[[i]] = getMAF(probs, map, chr, snp_func)

} # for(pr)

base_dir = '/media/dmgatti/hdb/projects/ColoState/data/plink'
writePLINK(probs, map, pheno, snp_func, path = file.path(base_dir, 'hsnpt_hze'))

# Write phenotype and covariate files.
# From PLINK docs: "In combination with --pheno, --mpheno lets you use the (n+2)th 
# column instead of the 3rd column, while --pheno-name lets you select a column by 
# title. (In order to use --pheno-name, there must be a header row with first two
# entries 'FID' and 'IID'.) The new --pheno-merge flag tells PLINK to use the 
# phenotype value in the .fam/.ped file when no value is present in the --pheno 
# file; without it, the phenotype is always treated as missing in this case."
pheno_plink = data.frame(FID    = 0,
                         IID    = rownames(pheno),
                         as.matrix(pheno[,-c(1:7, 10)] + 1))
write.table(pheno_plink, file = file.path(base_dir, 'hsnpt_hze_pheno.txt'), append = FALSE, sep = ' ', 
            row.names = FALSE, col.names = FALSE, quote = FALSE)

# From PLINK docs: "--covar designates the file to load covariates from. The 
# file format is the same as for --pheno (optional header line, FID and IID 
# in first two columns, covariates in remaining columns). By default, the main 
# phenotype is set to missing if any covariate is missing; you can disable 
# this with the 'keep-pheno-on-missing-cov' modifier."
# I'm not sure if PLINK includes sex by default since it's in the fam file.
# In qtl2, 0 = F and 1 = M. In PLINK, 1 = M and 2 = F.
sex = pheno$sex
sex[sex == 0] = 2
covar_plink = data.frame(FID = 0,
                         IID = rownames(pheno),
                         SEX = sex)
write.table(covar_plink, file = file.path(base_dir, 'hsnpt_hze_covar.txt'), append = FALSE, sep = ' ', 
            row.names = FALSE, col.names = FALSE, quote = FALSE)
